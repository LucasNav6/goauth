// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package entites

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAccount = `-- name: CreateAccount :one
INSERT INTO account (
    id, userId, accountId, providerId, accessToken, refreshToken,
    accessTokenExpiresAt, refreshTokenExpiresAt, scope, idToken, password, createdAt, updatedAt
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
)
RETURNING id, userid, accountid, providerid, accesstoken, refreshtoken, accesstokenexpiresat, refreshtokenexpiresat, scope, idtoken, password, createdat, updatedat
`

type CreateAccountParams struct {
	ID                    string
	Userid                string
	Accountid             string
	Providerid            string
	Accesstoken           pgtype.Text
	Refreshtoken          pgtype.Text
	Accesstokenexpiresat  pgtype.Timestamptz
	Refreshtokenexpiresat pgtype.Timestamptz
	Scope                 pgtype.Text
	Idtoken               pgtype.Text
	Password              pgtype.Text
	Createdat             pgtype.Timestamptz
	Updatedat             pgtype.Timestamptz
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, createAccount,
		arg.ID,
		arg.Userid,
		arg.Accountid,
		arg.Providerid,
		arg.Accesstoken,
		arg.Refreshtoken,
		arg.Accesstokenexpiresat,
		arg.Refreshtokenexpiresat,
		arg.Scope,
		arg.Idtoken,
		arg.Password,
		arg.Createdat,
		arg.Updatedat,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Userid,
		&i.Accountid,
		&i.Providerid,
		&i.Accesstoken,
		&i.Refreshtoken,
		&i.Accesstokenexpiresat,
		&i.Refreshtokenexpiresat,
		&i.Scope,
		&i.Idtoken,
		&i.Password,
		&i.Createdat,
		&i.Updatedat,
	)
	return i, err
}

const createSession = `-- name: CreateSession :one
INSERT INTO session (
    id, userId, token, expiresAt, ipAddress, userAgent, createdAt, updatedAt
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, userid, token, expiresat, ipaddress, useragent, createdat, updatedat
`

type CreateSessionParams struct {
	ID        string
	Userid    string
	Token     string
	Expiresat pgtype.Timestamptz
	Ipaddress pgtype.Text
	Useragent pgtype.Text
	Createdat pgtype.Timestamptz
	Updatedat pgtype.Timestamptz
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, createSession,
		arg.ID,
		arg.Userid,
		arg.Token,
		arg.Expiresat,
		arg.Ipaddress,
		arg.Useragent,
		arg.Createdat,
		arg.Updatedat,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.Userid,
		&i.Token,
		&i.Expiresat,
		&i.Ipaddress,
		&i.Useragent,
		&i.Createdat,
		&i.Updatedat,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO "user" (
    id, name, email, emailVerified, image, createdAt, updatedAt
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, name, email, emailverified, image, createdat, updatedat
`

type CreateUserParams struct {
	ID            string
	Name          pgtype.Text
	Email         pgtype.Text
	Emailverified bool
	Image         pgtype.Text
	Createdat     pgtype.Timestamptz
	Updatedat     pgtype.Timestamptz
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.Emailverified,
		arg.Image,
		arg.Createdat,
		arg.Updatedat,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Emailverified,
		&i.Image,
		&i.Createdat,
		&i.Updatedat,
	)
	return i, err
}

const createVerification = `-- name: CreateVerification :one
INSERT INTO verification (
    id, identifier, value, expiresAt, createdAt, updatedAt
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, identifier, value, expiresat, createdat, updatedat
`

type CreateVerificationParams struct {
	ID         string
	Identifier string
	Value      string
	Expiresat  pgtype.Timestamptz
	Createdat  pgtype.Timestamptz
	Updatedat  pgtype.Timestamptz
}

func (q *Queries) CreateVerification(ctx context.Context, arg CreateVerificationParams) (Verification, error) {
	row := q.db.QueryRow(ctx, createVerification,
		arg.ID,
		arg.Identifier,
		arg.Value,
		arg.Expiresat,
		arg.Createdat,
		arg.Updatedat,
	)
	var i Verification
	err := row.Scan(
		&i.ID,
		&i.Identifier,
		&i.Value,
		&i.Expiresat,
		&i.Createdat,
		&i.Updatedat,
	)
	return i, err
}

const deleteAccount = `-- name: DeleteAccount :exec
DELETE FROM account
WHERE id = $1
`

func (q *Queries) DeleteAccount(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteAccount, id)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM session
WHERE id = $1
`

func (q *Queries) DeleteSession(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteSession, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM "user"
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const deleteVerification = `-- name: DeleteVerification :exec
DELETE FROM verification
WHERE id = $1
`

func (q *Queries) DeleteVerification(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteVerification, id)
	return err
}

const getAccount = `-- name: GetAccount :one
SELECT id, userid, accountid, providerid, accesstoken, refreshtoken, accesstokenexpiresat, refreshtokenexpiresat, scope, idtoken, password, createdat, updatedat FROM account
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetAccount(ctx context.Context, id string) (Account, error) {
	row := q.db.QueryRow(ctx, getAccount, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Userid,
		&i.Accountid,
		&i.Providerid,
		&i.Accesstoken,
		&i.Refreshtoken,
		&i.Accesstokenexpiresat,
		&i.Refreshtokenexpiresat,
		&i.Scope,
		&i.Idtoken,
		&i.Password,
		&i.Createdat,
		&i.Updatedat,
	)
	return i, err
}

const getAccountByProviderAndUserId = `-- name: GetAccountByProviderAndUserId :one
SELECT id, userid, accountid, providerid, accesstoken, refreshtoken, accesstokenexpiresat, refreshtokenexpiresat, scope, idtoken, password, createdat, updatedat FROM account
WHERE providerId = $1
    AND userId = $2
LIMIT 1
`

type GetAccountByProviderAndUserIdParams struct {
	Providerid string
	Userid     string
}

func (q *Queries) GetAccountByProviderAndUserId(ctx context.Context, arg GetAccountByProviderAndUserIdParams) (Account, error) {
	row := q.db.QueryRow(ctx, getAccountByProviderAndUserId, arg.Providerid, arg.Userid)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Userid,
		&i.Accountid,
		&i.Providerid,
		&i.Accesstoken,
		&i.Refreshtoken,
		&i.Accesstokenexpiresat,
		&i.Refreshtokenexpiresat,
		&i.Scope,
		&i.Idtoken,
		&i.Password,
		&i.Createdat,
		&i.Updatedat,
	)
	return i, err
}

const getSession = `-- name: GetSession :one
SELECT id, userid, token, expiresat, ipaddress, useragent, createdat, updatedat FROM session
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetSession(ctx context.Context, id string) (Session, error) {
	row := q.db.QueryRow(ctx, getSession, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.Userid,
		&i.Token,
		&i.Expiresat,
		&i.Ipaddress,
		&i.Useragent,
		&i.Createdat,
		&i.Updatedat,
	)
	return i, err
}

const getSessionByToken = `-- name: GetSessionByToken :one
SELECT id, userid, token, expiresat, ipaddress, useragent, createdat, updatedat FROM session
WHERE token = $1
LIMIT 1
`

func (q *Queries) GetSessionByToken(ctx context.Context, token string) (Session, error) {
	row := q.db.QueryRow(ctx, getSessionByToken, token)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.Userid,
		&i.Token,
		&i.Expiresat,
		&i.Ipaddress,
		&i.Useragent,
		&i.Createdat,
		&i.Updatedat,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, name, email, emailverified, image, createdat, updatedat FROM "user"
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Emailverified,
		&i.Image,
		&i.Createdat,
		&i.Updatedat,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, name, email, emailverified, image, createdat, updatedat FROM "user"
WHERE email = $1
LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email pgtype.Text) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Emailverified,
		&i.Image,
		&i.Createdat,
		&i.Updatedat,
	)
	return i, err
}

const getVerification = `-- name: GetVerification :one
SELECT id, identifier, value, expiresat, createdat, updatedat FROM verification
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetVerification(ctx context.Context, id string) (Verification, error) {
	row := q.db.QueryRow(ctx, getVerification, id)
	var i Verification
	err := row.Scan(
		&i.ID,
		&i.Identifier,
		&i.Value,
		&i.Expiresat,
		&i.Createdat,
		&i.Updatedat,
	)
	return i, err
}

const getVerificationByIdentifier = `-- name: GetVerificationByIdentifier :many
SELECT id, identifier, value, expiresat, createdat, updatedat FROM verification
WHERE identifier = $1
ORDER BY expiresAt
`

func (q *Queries) GetVerificationByIdentifier(ctx context.Context, identifier string) ([]Verification, error) {
	rows, err := q.db.Query(ctx, getVerificationByIdentifier, identifier)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Verification
	for rows.Next() {
		var i Verification
		if err := rows.Scan(
			&i.ID,
			&i.Identifier,
			&i.Value,
			&i.Expiresat,
			&i.Createdat,
			&i.Updatedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccounts = `-- name: ListAccounts :many
SELECT id, userid, accountid, providerid, accesstoken, refreshtoken, accesstokenexpiresat, refreshtokenexpiresat, scope, idtoken, password, createdat, updatedat FROM account
ORDER BY createdAt
`

func (q *Queries) ListAccounts(ctx context.Context) ([]Account, error) {
	rows, err := q.db.Query(ctx, listAccounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.Userid,
			&i.Accountid,
			&i.Providerid,
			&i.Accesstoken,
			&i.Refreshtoken,
			&i.Accesstokenexpiresat,
			&i.Refreshtokenexpiresat,
			&i.Scope,
			&i.Idtoken,
			&i.Password,
			&i.Createdat,
			&i.Updatedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccountsByUserId = `-- name: ListAccountsByUserId :many
SELECT id, userid, accountid, providerid, accesstoken, refreshtoken, accesstokenexpiresat, refreshtokenexpiresat, scope, idtoken, password, createdat, updatedat FROM account
WHERE userId = $1
ORDER BY createdAt
`

func (q *Queries) ListAccountsByUserId(ctx context.Context, userid string) ([]Account, error) {
	rows, err := q.db.Query(ctx, listAccountsByUserId, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.Userid,
			&i.Accountid,
			&i.Providerid,
			&i.Accesstoken,
			&i.Refreshtoken,
			&i.Accesstokenexpiresat,
			&i.Refreshtokenexpiresat,
			&i.Scope,
			&i.Idtoken,
			&i.Password,
			&i.Createdat,
			&i.Updatedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessions = `-- name: ListSessions :many
SELECT id, userid, token, expiresat, ipaddress, useragent, createdat, updatedat FROM session
ORDER BY createdAt
`

func (q *Queries) ListSessions(ctx context.Context) ([]Session, error) {
	rows, err := q.db.Query(ctx, listSessions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Session
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.Userid,
			&i.Token,
			&i.Expiresat,
			&i.Ipaddress,
			&i.Useragent,
			&i.Createdat,
			&i.Updatedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessionsByUserId = `-- name: ListSessionsByUserId :many
SELECT id, userid, token, expiresat, ipaddress, useragent, createdat, updatedat FROM session
WHERE userId = $1
ORDER BY createdAt
`

func (q *Queries) ListSessionsByUserId(ctx context.Context, userid string) ([]Session, error) {
	rows, err := q.db.Query(ctx, listSessionsByUserId, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Session
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.Userid,
			&i.Token,
			&i.Expiresat,
			&i.Ipaddress,
			&i.Useragent,
			&i.Createdat,
			&i.Updatedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, name, email, emailverified, image, createdat, updatedat FROM "user"
ORDER BY createdAt
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Emailverified,
			&i.Image,
			&i.Createdat,
			&i.Updatedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVerifications = `-- name: ListVerifications :many
SELECT id, identifier, value, expiresat, createdat, updatedat FROM verification
ORDER BY createdAt
`

func (q *Queries) ListVerifications(ctx context.Context) ([]Verification, error) {
	rows, err := q.db.Query(ctx, listVerifications)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Verification
	for rows.Next() {
		var i Verification
		if err := rows.Scan(
			&i.ID,
			&i.Identifier,
			&i.Value,
			&i.Expiresat,
			&i.Createdat,
			&i.Updatedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccount = `-- name: UpdateAccount :exec
UPDATE account
SET userId = $2,
        accountId = $3,
        providerId = $4,
        accessToken = $5,
        refreshToken = $6,
        accessTokenExpiresAt = $7,
        refreshTokenExpiresAt = $8,
        scope = $9,
        idToken = $10,
        password = $11,
        updatedAt = $12
WHERE id = $1
`

type UpdateAccountParams struct {
	ID                    string
	Userid                string
	Accountid             string
	Providerid            string
	Accesstoken           pgtype.Text
	Refreshtoken          pgtype.Text
	Accesstokenexpiresat  pgtype.Timestamptz
	Refreshtokenexpiresat pgtype.Timestamptz
	Scope                 pgtype.Text
	Idtoken               pgtype.Text
	Password              pgtype.Text
	Updatedat             pgtype.Timestamptz
}

func (q *Queries) UpdateAccount(ctx context.Context, arg UpdateAccountParams) error {
	_, err := q.db.Exec(ctx, updateAccount,
		arg.ID,
		arg.Userid,
		arg.Accountid,
		arg.Providerid,
		arg.Accesstoken,
		arg.Refreshtoken,
		arg.Accesstokenexpiresat,
		arg.Refreshtokenexpiresat,
		arg.Scope,
		arg.Idtoken,
		arg.Password,
		arg.Updatedat,
	)
	return err
}

const updateSession = `-- name: UpdateSession :exec
UPDATE session
SET userId = $2,
        token = $3,
        expiresAt = $4,
        ipAddress = $5,
        userAgent = $6,
        updatedAt = $7
WHERE id = $1
`

type UpdateSessionParams struct {
	ID        string
	Userid    string
	Token     string
	Expiresat pgtype.Timestamptz
	Ipaddress pgtype.Text
	Useragent pgtype.Text
	Updatedat pgtype.Timestamptz
}

func (q *Queries) UpdateSession(ctx context.Context, arg UpdateSessionParams) error {
	_, err := q.db.Exec(ctx, updateSession,
		arg.ID,
		arg.Userid,
		arg.Token,
		arg.Expiresat,
		arg.Ipaddress,
		arg.Useragent,
		arg.Updatedat,
	)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE "user"
SET name = $2,
        email = $3,
        emailVerified = $4,
        image = $5,
        updatedAt = $6
WHERE id = $1
`

type UpdateUserParams struct {
	ID            string
	Name          pgtype.Text
	Email         pgtype.Text
	Emailverified bool
	Image         pgtype.Text
	Updatedat     pgtype.Timestamptz
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.Emailverified,
		arg.Image,
		arg.Updatedat,
	)
	return err
}

const updateVerification = `-- name: UpdateVerification :exec
UPDATE verification
SET identifier = $2,
        value = $3,
        expiresAt = $4,
        updatedAt = $5
WHERE id = $1
`

type UpdateVerificationParams struct {
	ID         string
	Identifier string
	Value      string
	Expiresat  pgtype.Timestamptz
	Updatedat  pgtype.Timestamptz
}

func (q *Queries) UpdateVerification(ctx context.Context, arg UpdateVerificationParams) error {
	_, err := q.db.Exec(ctx, updateVerification,
		arg.ID,
		arg.Identifier,
		arg.Value,
		arg.Expiresat,
		arg.Updatedat,
	)
	return err
}
